ğŸ§­ SOLID (5 princÃ­pios de design orientado a objetos)

S â€“ Single Responsibility: cada classe deve ter apenas uma responsabilidade.

O â€“ Open/Closed: aberto para extensÃ£o, fechado para modificaÃ§Ã£o.

L â€“ Liskov Substitution: subclasses devem poder substituir suas superclasses sem quebrar o cÃ³digo.

I â€“ Interface Segregation: interfaces especÃ­ficas, nÃ£o gigantes â€” melhor vÃ¡rios contratos pequenos.

D â€“ Dependency Inversion: dependa de abstraÃ§Ãµes, nÃ£o de implementaÃ§Ãµes concretas.

ğŸ§  Did you know: esses princÃ­pios foram popularizados por Robert C. Martin, o â€œUncle Bobâ€.

ğŸ§¬ HeranÃ§a

Permite que uma classe reutilize e estenda o comportamento de outra.
ğŸ‘‰ Exemplo: Cachorro herda de Animal e ganha comportamentos bÃ¡sicos automaticamente.

ğŸ§  Did you know: linguagens como Java nÃ£o suportam heranÃ§a mÃºltipla de classes â€” apenas de interfaces.

ğŸŒ€ Polimorfismo

Capacidade de um mesmo mÃ©todo se comportar de maneiras diferentes dependendo do objeto.
ğŸ‘‰ Exemplo: falar() pode emitir sons diferentes em Gato e Cachorro.

ğŸ§  Did you know: â€œpolimorfismoâ€ vem do grego e significa literalmente â€œmuitas formasâ€.

ğŸ­ Factory (Factory Method)

Fornece uma forma centralizada de criar objetos, escondendo a lÃ³gica de instÃ¢ncia.
ğŸ‘‰ Em vez de usar new direto, vocÃª chama um mÃ©todo fÃ¡brica.

ğŸ§  Did you know: esse padrÃ£o Ã© um dos mais usados em frameworks como Spring e Swing.

ğŸ¢ Abstract Factory

Cria famÃ­lias de objetos relacionados sem especificar suas classes concretas.
ğŸ‘‰ Ideal para criar grupos de objetos que devem funcionar juntos (ex: botÃµes e janelas em diferentes SOs).

ğŸ§  Did you know: esse padrÃ£o evita dependÃªncia direta de classes especÃ­ficas â€” super Ãºtil para portabilidade.

ğŸ§ Singleton

Garante que existe apenas uma instÃ¢ncia de uma classe e fornece acesso global a ela.
ğŸ‘‰ Exemplo: gerenciador de configuraÃ§Ãµes ou conexÃ£o com banco.

ğŸ§  Did you know: Ã© um dos padrÃµes mais polÃªmicos â€” Ãºtil, mas mal usado pode virar â€œglobal mal disfarÃ§adoâ€.

ğŸ•Šï¸ Observer

Permite que mÃºltiplos objetos sejam notificados automaticamente quando algo muda.
ğŸ‘‰ Exemplo: sistema de notificaÃ§Ãµes, onde vÃ¡rios â€œouvintesâ€ recebem atualizaÃ§Ãµes de um â€œsujeitoâ€.

ğŸ§  Did you know: esse padrÃ£o Ã© a base de sistemas de eventos, como os do JavaScript.

ğŸ§ª Prototype

Cria novos objetos copiando um objeto existente (clone), em vez de criar do zero.
ğŸ‘‰ Ãštil quando instanciar Ã© caro ou complexo.

ğŸ§  Did you know: esse padrÃ£o inspirou parte do modelo de heranÃ§a por protÃ³tipo do JavaScript.

ğŸ¨ Decorator

Adiciona comportamentos extras a um objeto de forma flexÃ­vel, sem alterar sua estrutura original.
ğŸ‘‰ Exemplo: adicionar bordas e sombras a um componente grÃ¡fico.

ğŸ§  Did you know: o BufferedReader no Java Ã© um decorador do Reader!

ğŸ§­ Strategy

Define uma famÃ­lia de algoritmos intercambiÃ¡veis, permitindo mudar o comportamento em tempo de execuÃ§Ã£o.
ğŸ‘‰ Exemplo: diferentes formas de calcular frete ou rotas.

ğŸ§  Did you know: Strategy evita ifs e switches enormes, tornando o cÃ³digo mais limpo e extensÃ­vel.

ğŸ”Œ Adapter

Permite que classes incompatÃ­veis trabalhem juntas convertendo uma interface na outra.
ğŸ‘‰ Exemplo: usar um carregador de tomada americana em uma tomada brasileira.

ğŸ§  Did you know: esse padrÃ£o Ã© tÃ£o comum que vocÃª provavelmente jÃ¡ usou um â€œadapterâ€ fÃ­sico na vida real ğŸ˜„